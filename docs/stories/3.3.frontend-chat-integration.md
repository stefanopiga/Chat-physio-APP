# Story 3.3: Frontend Chat Integration

**Status:** Done

## Story

**As a** Sviluppatore Frontend,
**I want** collegare la UI della chat agli endpoint,
**so that** gli studenti possano avere una conversazione fluida.

[Fonte: `docs/prd/sezione-9-epic-3-dettagli-interactive-rag-experience.md`]

## Acceptance Criteria

1. La UI chiama l'endpoint `/api/v1/chat/query`.
2. Mostra un indicatore di caricamento.
3. Visualizza la risposta.
4. Mantiene la cronologia della sessione con `sessionId` persistito lato client (es. `localStorage`, chiave `chat.sessionId`).

[Fonte: `docs/prd/sezione-9-epic-3-dettagli-interactive-rag-experience.md`]

## Dev Notes

### Contexto Tecnico
- Backend disponibile:
  - `POST /api/v1/chat/query` per ricerca semantica (Story 3.1). [Fonti: `docs/stories/3.1.semantic-search-endpoint.md`]
  - `POST /api/v1/chat/sessions/{sessionId}/messages` per AG (Story 3.2). [Fonti: `docs/stories/3.2.augmented-generation-endpoint.md`]
- Autenticazione: JWT Supabase.
- Rate limiting: 60/min.

### Flusso UI
1. Input domanda → chiama `POST /api/v1/chat/query` includendo `sessionId` e `question` per ottenere `chunks`.
2. Recupera `sessionId` da `localStorage` (chiave `chat.sessionId`); se assente, genera un UUID v4 e salva.
3. Invoca `POST /api/v1/chat/sessions/{sessionId}/messages` con `question` e `chunks`. 
4. Visualizza `answer` e associa citazioni (placeholder; implementazione completa in 3.4).
5. Aggiorna la cronologia chat locale.

### Componenti Frontend
- `ChatPage`: orchestrazione flusso, gestione `sessionId` (persistenza `localStorage` chiave `chat.sessionId`) e stato conversazione.
- `ChatInput`: input domanda con submit/loader.
- `ChatMessagesList`: rendering messaggi con citazioni placeholder.
- `apiClient`: funzioni `queryChunks(question)` e `sendMessage(sessionId, question, chunks)`.

### Error Handling
- 401 → reindirizza a login.
- 429 → messaggio rate limit.
- 500 → toast/errore generico.

## Testing
- Test di integrazione UI: mock API client, verifica chiamate e rendering loader/risposta.
- E2E: prerequisiti per rotte protette (`AuthGuard`) impostati prima di `goto`:
```ts
await page.addInitScript(() => {
  localStorage.setItem("chat.sessionId", "e2e-session-id");
  sessionStorage.setItem("temp_jwt", "e2e-temp-token");
});
await page.goto("/chat");
```
- Attendere sblocco `AuthGuard` prima di interagire:
```ts
await expect(page.getByText("Verifica autenticazione...")).not.toBeVisible({ timeout: 10000 });
```
- Attese esplicite su input chat e abilitazione submit, verifica comparsa del loader:
```ts
const input = page.getByPlaceholder("Inserisci la tua domanda...");
await expect(input).toBeVisible({ timeout: 10000 });
const submit = page.getByRole("button", { name: "Invia" });
await expect(submit).toBeEnabled();
await submit.click();
await expect(page.getByText("Caricamento...")).toBeVisible();
```

## File Locations
- Frontend: `/apps/web/`
- API: `/apps/api/`
- Docs: `/docs/`

## Tasks / Subtasks
- [x] Implementare `apiClient` con funzioni `queryChunks` e `sendMessage`.
- [x] Creare componenti `ChatPage`, `ChatInput`, `ChatMessagesList` con stato e flusso base.
- [x] Gestire `sessionId` persistente (localStorage) e cronologia locale.
- [x] Gestire loader, errori di base e edge cases.
- [x] Test di integrazione/E2E aggiornati con prerequisiti e attese robuste.
