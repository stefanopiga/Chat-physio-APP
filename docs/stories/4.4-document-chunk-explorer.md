# Story 4.4: Document Chunk Explorer

**Status:** Done

## Metadata
- **ID**: 4.4
- **Type**: Feature / Post-MVP Enhancement
- **Epic**: Epic 4 — Post-MVP Enhancements
- **Priority**: Medium
- **Complexity**: Medium
- **Effort Estimate**: 6-9 ore

---

## Story

**As a** Professore (Admin),  
**I want** visualizzare tutti i chunk generati per un documento specifico,  
**so that** posso verificare la qualità del chunking, identificare problemi di segmentazione e valutare necessità di re-indicizzazione.

**Business Value**: Abilitare quality assurance sul processo di chunking, migliorare qualità retrieval identificando chunk mal formati o poco informativi, ottimizzare strategie di chunking per contenuti specifici.

---

## Context & Background

### Current State
- Documents ingeriti tramite Story 2.1 (Document Loader)
- Chunking polimorfico tramite Story 2.3 (Polymorphic Chunking Router)
- Chunks indicizzati in Supabase via Story 2.4 (Vector Indexing)
- Nessun tool admin per ispezionare chunk generati da documento specifico

### Problem
Admin non ha visibilità su:
- Qualità chunking output per documento
- Distribuzione dimensioni chunk
- Metadata associati (chunking strategy, document source)
- Chunk potenzialmente mal formati (troppo corti/lunghi, contenuto troncato)

### Desired State
Admin può:
1. Selezionare un documento dalla lista documenti indicizzati
2. Visualizzare tutti i chunk generati per quel documento
3. Ispezionare content, metadata, embedding status per ogni chunk
4. Identificare chunk problematici
5. Opzionalmente: trigger re-indicizzazione documento

---

## Acceptance Criteria

1. **Document List View**: `/admin/documents` mostra tabella documenti indicizzati con colonne: nome documento, data upload, numero chunk generati, chunking strategy usata

2. **Chunk Explorer View**: Click su documento → navigazione a `/admin/documents/{document_id}/chunks` con lista chunk

3. **Chunk Display**: Ogni chunk visualizzato con:
   - Content preview (primi 300 caratteri + "..." se troncato)
   - Chunk sequence number/ID
   - Chunk size (caratteri)
   - Metadata: chunking strategy, page number (se disponibile), document source
   - Embedding status (indexed/pending)

4. **Chunk Expansion**: Click su chunk → dialog/accordion con full content visualizzato

5. **Filtering**: Filtri per:
   - Chunking strategy (recursive, semantic, by_title, by_page)
   - Chunk size range (min/max caratteri)

6. **Sorting**: Ordina chunk per:
   - Sequence number (default)
   - Chunk size
   - Creation date

7. **Empty State**: Se documento non ha chunk indicizzati, mostra messaggio chiaro

8. **Responsive Design**: Layout funzionale su mobile/desktop

9. **Performance**: Caricamento lista chunk < 500ms per documento con 200 chunk

10. **Access Control**: Funzionalità accessibile solo ad admin autenticati (AdminGuard)

---

## Technical Implementation

### Database Schema (già esistente)

**Table**: `document_chunks` (Story 2.4)

```sql
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL,
    content TEXT NOT NULL,
    embedding VECTOR(1536),
    metadata JSONB,  -- include: chunking_strategy, page_number, source
    chunk_index INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Metadata JSONB structure**:
```json
{
  "chunking_strategy": "recursive|semantic|by_title|by_page",
  "page_number": 12,
  "document_name": "anatomia_spalla.pdf",
  "chunk_size": 850
}
```

### Database Connection Pattern

**Libreria**: `asyncpg` (query SQL dirette asincrone con connection pooling)

**Motivazione**: Endpoint richiedono query di aggregazione complesse (MODE() WITHIN GROUP, JOIN multipli, GROUP BY). Pattern asyncpg garantisce:
- Connection pooling con riutilizzo connessioni
- Performance ottimali per query analitiche
- Query parametrizzate native PostgreSQL (SQL injection safe)
- Pattern async allineato con FastAPI best practices

**Setup**:
1. Aggiungere `asyncpg = "^0.30.0"` in `apps/api/pyproject.toml`
2. Configurare `DATABASE_URL` in `apps/api/.env`
3. Connection pool inizializzato tramite lifespan events FastAPI
4. Dependency injection `get_db_connection()` per endpoint

**Riferimento Completo**: `docs/architecture/addendum-asyncpg-database-pattern.md`

---

### Backend Implementation

**Endpoint 1**: `GET /api/v1/admin/documents`

**Response Model**:
```python
class DocumentSummary(BaseModel):
    document_id: str
    document_name: str
    upload_date: str  # ISO datetime
    chunk_count: int
    primary_chunking_strategy: str  # strategia predominante

class DocumentListResponse(BaseModel):
    documents: list[DocumentSummary]
    total_count: int
```

**Implementation Pattern**:
```python
from typing import Annotated
from fastapi import Depends
import asyncpg
from .database import get_db_connection

@app.get("/api/v1/admin/documents", response_model=DocumentListResponse)
async def get_documents(
    conn: Annotated[asyncpg.Connection, Depends(get_db_connection)],
):
    """
    Recupera lista documenti con metadata aggregati.
    
    Features:
    - MODE() WITHIN GROUP per strategia predominante
    - COUNT aggregato per numero chunk
    - LEFT JOIN per includere documenti senza chunk
    """
    query = """
        SELECT 
            d.id AS document_id,
            d.name AS document_name,
            d.created_at AS upload_date,
            COUNT(c.id) AS chunk_count,
            MODE() WITHIN GROUP (ORDER BY c.metadata->>'chunking_strategy') AS primary_chunking_strategy
        FROM documents d
        LEFT JOIN document_chunks c ON d.id = c.document_id
        GROUP BY d.id, d.name, d.created_at
        ORDER BY d.created_at DESC
    """
    
    rows = await conn.fetch(query)
    documents = [dict(row) for row in rows]
    
    return DocumentListResponse(
        documents=documents,
        total_count=len(documents)
    )
```

**PostgreSQL Features**:
- `MODE() WITHIN GROUP`: Funzione aggregazione ordered-set per trovare valore più frequente
- `LEFT JOIN`: Include documenti senza chunk (chunk_count = 0)
- `JSONB extraction`: `metadata->>'chunking_strategy'` estrae valore da campo JSONB

**Riferimenti**:
- asyncpg pattern: `docs/architecture/addendum-asyncpg-database-pattern.md` (Sezione 5)
- MODE() syntax: PostgreSQL docs (Ordered-Set Aggregate Functions)

---

**Endpoint 2**: `GET /api/v1/admin/documents/{document_id}/chunks`

**Query Parameters** (Pattern: Dependency Classes):
- `strategy` (optional): filter by chunking_strategy
- `min_size`, `max_size` (optional): filter by chunk size
- `sort_by` (optional): `sequence|size|created_at` (default: sequence)
- `limit`, `offset` (optional): pagination

**Response Model**:
```python
class ChunkDetail(BaseModel):
    chunk_id: str
    content: str
    chunk_size: int
    chunk_index: int
    chunking_strategy: str
    page_number: Optional[int]
    embedding_status: Literal["indexed", "pending"]
    created_at: str

class DocumentChunksResponse(BaseModel):
    document_id: str
    document_name: str
    chunks: list[ChunkDetail]
    total_chunks: int
```

**Implementation Pattern** (con Parameter Classes):
```python
from typing import Annotated
from fastapi import Depends, Query
import asyncpg

# Classi riutilizzabili per parametri
class PaginationParams:
    def __init__(
        self,
        skip: int = Query(0, ge=0, description="Number of records to skip"),
        limit: int = Query(100, ge=1, le=1000, description="Max records to return")
    ):
        self.skip = skip
        self.limit = limit

class ChunkFilterParams:
    def __init__(
        self,
        strategy: str | None = Query(None, description="Filter by chunking strategy"),
        min_size: int | None = Query(None, ge=0, description="Minimum chunk size"),
        sort_by: str = Query("chunk_index", regex="^(chunk_index|created_at|size)$")
    ):
        self.strategy = strategy
        self.min_size = min_size
        self.sort_by = sort_by

@app.get("/api/v1/admin/documents/{document_id}/chunks")
async def get_document_chunks(
    document_id: str,
    conn: Annotated[asyncpg.Connection, Depends(get_db_connection)],
    pagination: Annotated[PaginationParams, Depends()],
    filters: Annotated[ChunkFilterParams, Depends()]
):
    """
    Recupera chunk per documento con filtri opzionali.
    
    Features:
    - Query parametrizzate con $1, $2 (SQL injection safe)
    - Filtri dinamici opzionali
    - Paginazione
    - Sort configurabile
    """
    # Query base
    query_parts = ["""
        SELECT 
            c.id AS chunk_id,
            c.content,
            LENGTH(c.content) AS chunk_size,
            c.chunk_index,
            c.metadata->>'chunking_strategy' AS chunking_strategy,
            (c.metadata->>'page_number')::INTEGER AS page_number,
            CASE WHEN c.embedding IS NOT NULL THEN 'indexed' ELSE 'pending' END AS embedding_status,
            c.created_at
        FROM document_chunks c
        WHERE c.document_id = $1
    """]
    
    params = [document_id]
    param_idx = 2
    
    # Filtro opzionale per strategia
    if filters.strategy:
        query_parts.append(f"AND c.metadata->>'chunking_strategy' = ${param_idx}")
        params.append(filters.strategy)
        param_idx += 1
    
    # Filtro opzionale per dimensione minima
    if filters.min_size:
        query_parts.append(f"AND LENGTH(c.content) >= ${param_idx}")
        params.append(filters.min_size)
        param_idx += 1
    
    # Sort e paginazione
    query_parts.append(f"ORDER BY c.{filters.sort_by}")
    query_parts.append(f"LIMIT ${param_idx} OFFSET ${param_idx + 1}")
    params.extend([pagination.limit, pagination.skip])
    
    query = " ".join(query_parts)
    rows = await conn.fetch(query, *params)
    
    # Count totale (senza paginazione)
    count_query = "SELECT COUNT(*) FROM document_chunks WHERE document_id = $1"
    total = await conn.fetchval(count_query, document_id)
    
    return DocumentChunksResponse(
        document_id=document_id,
        document_name="",  # Da recuperare con query separata
        chunks=[ChunkDetail(**dict(row)) for row in rows],
        total_chunks=total
    )
```

**Riferimenti**:
- Parameter Classes: `docs/architecture/addendum-asyncpg-database-pattern.md` (Sezione 7)
- Query parametrizzate: `docs/architecture/addendum-asyncpg-database-pattern.md` (Sezione 4)

---

### Frontend Implementation

**Prerequisites - Shadcn/UI Components**:

**Componenti Installati per Story 4.4**:
```bash
cd apps/web

# Nuove installazioni Story 4.4
pnpm dlx shadcn@latest add select   # Filtri dropdown strategia/ordinamento
pnpm dlx shadcn@latest add badge    # Badge chunking strategy status
pnpm dlx shadcn@latest add button   # Buttons azioni navigazione

# Componenti già disponibili da storie precedenti
# - Dialog (verificato in HelpModal.tsx)
# - Card (installato Story 4.1.5)
```

**Files Generati**:
- `apps/web/src/components/ui/select.tsx` ✅
- `apps/web/src/components/ui/badge.tsx` ✅
- `apps/web/src/components/ui/button.tsx` ✅
- `apps/web/src/components/ui/dialog.tsx` (già esistente)
- `apps/web/src/components/ui/card.tsx` (già esistente)

**Riferimenti Componenti**:
- **Select**: Filtri dropdown per strategia chunking e ordinamento
- **Badge**: Status indicator per chunking strategy ed embedding status
- **Button**: Navigazione tra pagine e trigger dialog
- **Dialog**: Modal per visualizzazione contenuto completo chunk
- **Card**: Container per lista documenti e chunk
- Pattern esistente: `src/components/HelpModal.tsx` (uso Dialog)
- Documentazione Dialog: `docs/architecture/addendum-shadcn-dialog-implementation.md`
- Registry completo: `docs/architecture/addendum-shadcn-components-registry.md`

---

**File**: `/apps/web/src/pages/DocumentsPage.tsx` (nuovo)

**Route**: `/admin/documents` (protetta da `AdminGuard`)

**UI Structure**:
```tsx
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Link } from "react-router-dom";

<div className="mx-auto max-w-7xl space-y-6 p-4">
  <div className="space-y-1">
    <h1>Document Explorer</h1>
    <p>Visualizza e analizza chunk generati per ogni documento</p>
  </div>

  {/* Documents Table */}
  <Card>
    <table>
      <thead>
        <tr>
          <th>Documento</th>
          <th>Data Upload</th>
          <th>Chunk Count</th>
          <th>Strategia</th>
          <th>Azioni</th>
        </tr>
      </thead>
      <tbody>
        {documents.map(doc => (
          <tr key={doc.document_id}>
            <td>{doc.document_name}</td>
            <td>{formatDate(doc.upload_date)}</td>
            <td>{doc.chunk_count}</td>
            <td><Badge>{doc.primary_chunking_strategy}</Badge></td>
            <td>
              <Link to={`/admin/documents/${doc.document_id}/chunks`}>
                <Button size="sm">Visualizza Chunk</Button>
              </Link>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  </Card>
</div>
```

---

**File**: `/apps/web/src/pages/DocumentChunksPage.tsx` (nuovo)

**Route**: `/admin/documents/:documentId/chunks`

**UI Structure**:
```tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Link } from "react-router-dom";

<div className="mx-auto max-w-7xl space-y-6 p-4">
  <div className="flex items-center justify-between">
    <div>
      <Link to="/admin/documents">← Back to Documents</Link>
      <h1>{documentName}</h1>
      <p>{totalChunks} chunk generati</p>
    </div>
    <div className="flex gap-2">
      {/* Filters - Componente Select */}
      <Select onValueChange={handleStrategyFilter}>
        <SelectTrigger className="w-[180px]">
          <SelectValue placeholder="Strategy" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All</SelectItem>
          <SelectItem value="recursive">Recursive</SelectItem>
          <SelectItem value="semantic">Semantic</SelectItem>
          <SelectItem value="by_title">By Title</SelectItem>
          <SelectItem value="by_page">By Page</SelectItem>
        </SelectContent>
      </Select>
      
      {/* Sort - Componente Select */}
      <Select onValueChange={handleSort}>
        <SelectTrigger className="w-[180px]">
          <SelectValue placeholder="Sort By" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="sequence">Sequence</SelectItem>
          <SelectItem value="size">Size</SelectItem>
          <SelectItem value="created_at">Date</SelectItem>
        </SelectContent>
      </Select>
    </div>
  </div>

  {/* Chunks List */}
  <div className="space-y-4">
    {chunks.map(chunk => (
      <Card key={chunk.chunk_id}>
        <CardHeader>
          <div className="flex items-start justify-between">
            <div>
              <CardTitle className="text-sm">Chunk #{chunk.chunk_index}</CardTitle>
              <CardDescription>
                {chunk.chunk_size} caratteri | {chunk.chunking_strategy}
                {chunk.page_number && ` | Pagina ${chunk.page_number}`}
              </CardDescription>
            </div>
            <Badge variant={chunk.embedding_status === 'indexed' ? 'default' : 'secondary'}>
              {chunk.embedding_status}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="text-sm">
            {chunk.content.length > 300 
              ? chunk.content.substring(0, 300) + "..." 
              : chunk.content}
          </div>
          {chunk.content.length > 300 && (
            <Dialog>
              <DialogTrigger asChild>
                <Button variant="link" size="sm">Mostra contenuto completo</Button>
              </DialogTrigger>
              <DialogContent className="max-h-[600px] overflow-y-auto sm:max-w-[600px]">
                <DialogHeader>
                  <DialogTitle>Chunk #{chunk.chunk_index} - Full Content</DialogTitle>
                </DialogHeader>
                <div className="whitespace-pre-wrap text-sm">{chunk.content}</div>
              </DialogContent>
            </Dialog>
          )}
        </CardContent>
      </Card>
    ))}
  </div>
</div>
```

**Componenti Shadcn/UI Utilizzati**:
- **Select**: Dropdown per filtro strategia e ordinamento
  - `SelectTrigger`: Bottone apertura dropdown
  - `SelectContent`: Container opzioni
  - `SelectItem`: Singola opzione selezionabile
  - `SelectValue`: Placeholder o valore selezionato
- **Dialog**: Modal per contenuto completo chunk
  - `DialogTrigger`: Elemento che attiva apertura (con `asChild` delega a Button)
  - `DialogContent`: Finestra modale
  - `DialogHeader`, `DialogTitle`: Header strutturato
  - Pattern accessibile: ESC chiude, click outside chiude, focus trap

**Riferimenti UI**:
- Select usage: Story 4.4 requirements (filtri dropdown)
- Dialog pattern: `src/components/HelpModal.tsx` (implementazione esistente)
- Dialog docs: `docs/architecture/addendum-shadcn-dialog-implementation.md`

---

## Dependencies

**Prerequisiti**:
- ✅ Story 2.1 (Document Loader) - Done
- ✅ Story 2.3 (Polymorphic Chunking Router) - Done
- ✅ Story 2.4 (Vector Indexing Supabase) - Done
- ✅ Story 4.1.5 (Admin Dashboard Hub) - Done (UI pattern Card/Badge)
- ✅ Shadcn/UI Select - Installato
- ✅ Shadcn/UI Dialog - Già disponibile (verificato in HelpModal.tsx)

**Dipendenze Backend**:
- ✅ asyncpg - Installato
- ✅ FastAPI - Già configurato
- ✅ Supabase/PostgreSQL - Database operativo

**Dipendenze Frontend**:
- ✅ React Router - Già configurato
- ✅ Tailwind CSS + Shadcn/UI base - Già disponibili
- ✅ Card, Badge, Button components - Già disponibili

---

## Out of Scope

- **Re-indicizzazione documento**: trigger manual reprocessing (future Story 4.4.1)
- **Chunk editing**: modifica manuale content chunk (violazione integrità sistema)
- **Chunk deletion**: eliminazione singolo chunk (future enhancement)
- **Chunk quality scoring**: ML-based quality assessment (future Epic 5)
- **Chunk similarity heatmap**: visualizzazione grafica similarità chunk (advanced analytics)
- **Bulk operations**: re-indicizzazione multipla documenti (future enhancement)

---

## Risks

| ID | Description | Probability | Impact | Mitigation |
|----|-------------|-------------|--------|------------|
| R-4.4-1 | Performance lenta con documenti > 500 chunk | Media | Medio | Pagination obbligatoria (default 50 chunk/page); lazy loading |
| R-4.4-2 | Metadata inconsistenti se schema cambia | Bassa | Medio | Validation fallback: metadata mancanti → display "N/A" |
| R-4.4-3 | Document table non esiste in Supabase | Alta | Alto | **BLOCKER**: Verificare schema DB; creare migration se necessario |
| R-4.4-4 | Large chunk content overflow UI | Bassa | Basso | Content preview + dialog per full content; max-height con scroll |
| R-4.4-5 | Admin abuse: query massive su documenti grandi | Bassa | Medio | Rate limiting: 30 req/hour per admin (pattern Story 4.2) |

---

## Testing Strategy

### Backend Unit Tests

**File**: `apps/api/tests/test_document_explorer.py`

**Test Cases**: 6 test
1. GET /admin/documents - 200 con lista documenti
2. GET /admin/documents - 403 per non-admin
3. GET /documents/{id}/chunks - 200 con chunk list
4. GET /documents/{id}/chunks - filtro per strategy funziona
5. GET /documents/{id}/chunks - sort per size funziona
6. GET /documents/{id}/chunks - pagination funziona

**Coverage Target**: ≥85%

---

### Frontend Unit Tests

**File**: `apps/web/src/pages/__tests__/DocumentsPage.test.tsx`

**Test Cases**: 8 test
1. Rendering tabella documenti
2. Navigazione a chunk page su click riga
3. Empty state quando zero documenti
4. Loading skeleton durante fetch
5. Error state con messaggio errore
6. Badge chunking strategy colori corretti
7. Sort per colonna tabella
8. Filter dropdown strategy

**Coverage Target**: ≥90%

---

### E2E Tests

**File**: `apps/web/tests/story-4.4.spec.ts`

**Scenarios**: 6 test
1. Admin login → navigazione /admin/documents → tabella visibile
2. Click documento → navigazione a chunks page → chunk list renderizzata
3. Click "Mostra contenuto completo" → dialog aperto con full content
4. Filter per strategy → chunk list aggiornata
5. Sort per size → chunk riordinati
6. Non-admin redirect da /admin/documents

**Duration Target**: < 30 secondi totali

---

## Success Metrics

- **Adoption**: ≥50% admin sessions usano Document Explorer almeno 1 volta/settimana
- **Quality Improvement**: PO identifica ≥3 documenti con chunking sub-ottimale entro 2 settimane deploy
- **Performance**: Caricamento chunk list < 500ms (p95) per documento con 200 chunk
- **Usability**: Zero tickets support su "come verificare chunking documento"

---

## Implementation Notes

### Fase 1: Backend Setup & Endpoints (Giorno 1-2)

**Prerequisiti**:
1. [x] Installare asyncpg: `cd apps/api && poetry add asyncpg`
2. [x] Creare `apps/api/api/database.py` con connection pool setup
3. [x] Configurare `DATABASE_URL` in `apps/api/.env`
4. [x] Integrare lifespan in `main.py`
5. [x] Verificare schema DB: esistenza table `documents` e `document_chunks`
6. [x] Verificare metadata JSONB include `chunking_strategy`, `page_number`
7. [x] Creare migration se necessario

**Implementation**:
1. Creare modelli Pydantic: `DocumentSummary`, `ChunkDetail`, parameter classes
2. Endpoint `GET /api/v1/admin/documents` con MODE() WITHIN GROUP query
3. Endpoint `GET /api/v1/admin/documents/{id}/chunks` con filters/sort/pagination
4. Rate limiting: 30 req/hour per admin (pattern Story 4.1)
5. Auth guard: admin-only con JWT verification
6. Unit tests (6 test case)

**Acceptance**: Backend endpoints funzionanti, connection pool operativo, test PASS

**Riferimenti Tecnici**:
- asyncpg setup: `docs/architecture/addendum-asyncpg-database-pattern.md` (Sezioni 2-3)
- Auth pattern: `docs/architecture/addendum-fastapi-best-practices.md` (Sezione 1)
- Parameter classes: `docs/architecture/addendum-asyncpg-database-pattern.md` (Sezione 7)

---

### Fase 2: Frontend UI (Giorno 3-5)

**Prerequisiti**:
1. [x] Installare Shadcn Select: `cd apps/web && pnpm dlx shadcn@latest add select`
2. [x] Verificare Dialog disponibile (già in HelpModal.tsx)

**Implementation**:
1. Creare `DocumentsPage.tsx` con tabella documenti
   - Card component per container
   - Badge per strategia chunking
   - Link navigazione a chunks page
2. Creare `DocumentChunksPage.tsx` con lista chunk
   - Card per ogni chunk con preview content
   - Select dropdown per filtro strategia
   - Select dropdown per sort order
   - Dialog per contenuto completo chunk (pattern HelpModal)
3. Implementare fetch API con error handling
4. Loading/error states
5. Unit tests (8 test case)

**Acceptance**: UI funzionale localhost, componenti installati, unit tests PASS

**Riferimenti UI**:
- Select examples: story4.4-docs.md materiale integrativo
- Dialog pattern: `src/components/HelpModal.tsx` (implementazione esistente)
- Dialog docs: `docs/architecture/addendum-shadcn-dialog-implementation.md`

---

### Fase 3: Integration & E2E (Giorno 6)

**Implementation**:
1. Aggiungere navigation link in `DashboardPage.tsx`:
   - Card "Document Explorer" con link `/admin/documents`
2. E2E tests (6 scenarios)
3. Performance testing: caricamento 200 chunk

**Acceptance**: E2E tests PASS, performance < 500ms

---

## File Locations

- Backend endpoints: `apps/api/api/main.py` (o nuovo file `apps/api/api/documents/routes.py`)
- Backend tests: `apps/api/tests/test_document_explorer.py`
- Frontend documents page: `apps/web/src/pages/DocumentsPage.tsx`
- Frontend chunks page: `apps/web/src/pages/DocumentChunksPage.tsx`
- Frontend tests: `apps/web/src/pages/__tests__/DocumentsPage.test.tsx`
- E2E tests: `apps/web/tests/story-4.4.spec.ts`
- Dashboard integration: `apps/web/src/pages/DashboardPage.tsx` (aggiornamento)

---

## Tasks / Subtasks

### Database Verification
- [x] Verificare schema `documents` table in Supabase
- [x] Verificare metadata JSONB structure in `document_chunks`
- [x] Creare migration se necessario per table `documents`

### Backend Implementation
- [x] Creare modelli Pydantic `DocumentSummary`, `ChunkDetail`
- [x] Implementare endpoint `GET /admin/documents`
- [x] Implementare endpoint `GET /admin/documents/{id}/chunks` con filters/sort
- [x] Aggregation query Supabase per document list
- [x] Query Supabase per chunk list con pagination
- [x] Rate limiting decorator (30 req/hour)
- [x] Unit tests (6 test case) - PASSED

### Frontend Implementation
- [x] Installare Shadcn Dialog, Select se mancanti
- [x] Creare `DocumentsPage.tsx` (tabella documenti)
- [x] Creare `DocumentChunksPage.tsx` (lista chunk)
- [x] Implementare filter dropdown (strategy)
- [x] Implementare sort dropdown (sequence/size/date)
- [x] Dialog full content chunk
- [x] Loading/error states
- [x] Unit tests (8 test case) - PASSED

### Integration & Testing
- [x] Aggiungere card "Document Explorer" in `DashboardPage.tsx`
- [x] Route `/admin/documents` protetta da AdminGuard
- [x] E2E tests (6 scenarios) - PASSED
- [x] Performance test: 200 chunk load < 500ms
- [x] Regression tests: Story 4.1, 4.1.5, 4.2 unchanged

---

## References

### Parent Epic
- Epic 4: `docs/prd/sezione-epic-4-dettagli-post-mvp-enhancements.md`

### Related Stories
- Story 2.1: `docs/stories/2.1.document-loader-and-text-extractor.md` (document ingestion)
- Story 2.3: `docs/stories/2.3.polymorphic-chunking-router.md` (chunking strategies)
- Story 2.4: `docs/stories/2.4.vector-indexing-in-supabase.md` (chunk storage schema)
- Story 4.1: `docs/stories/4.1.admin-debug-view.md` (admin UI pattern)
- Story 4.1.5: `docs/stories/4.1.5-admin-dashboard-hub.md` (Card pattern, AdminGuard)

### Architecture
- **asyncpg Pattern**: `docs/architecture/addendum-asyncpg-database-pattern.md` (connection pooling, query parametrizzate, aggregazioni)
- **FastAPI Best Practices**: `docs/architecture/addendum-fastapi-best-practices.md` (auth, async endpoints, error handling)
- **Shadcn/UI Dialog**: `docs/architecture/addendum-shadcn-dialog-implementation.md` (modal pattern)
- **Shadcn/UI Components Registry**: `docs/architecture/addendum-shadcn-components-registry.md` (installazioni componenti, usage patterns)
- Database Schema: `docs/architecture/sezione-4-modelli-di-dati.md`
- Supabase Integration: `docs/architecture/addendum-pgvector-langchain-supabase.md`
- Tech Stack: `docs/architecture/sezione-3-tech-stack.md`

---

## Change Log

| Date | Author | Change Description |
|------|--------|-------------------|
| 2025-10-04 | AI | Initial draft - Document Chunk Explorer Story 4.4 |
| 2025-10-04 | AI | Integrazione materiale tecnico: asyncpg pattern, Shadcn Select/Dialog, MODE() WITHIN GROUP, parameter classes FastAPI. Aggiunto addendum architettura asyncpg. Aggiornati riferimenti e implementation notes. |
| 2025-10-05 | AI | Implementation completata. Test risultati: Backend 6/6 PASSED, Frontend 8/8 PASSED, E2E 6/6 PASSED. Status aggiornato a "Implemented & Tested". Tutti prerequisiti e task completati. |

---

**Status**: ✅ Implemented & Tested  
**Priority**: Medium (Post Story 4.2 deployment)  
**Completion Date**: 2025-10-05  
**Test Results**: 
- Backend Unit Tests: 6/6 PASSED (6.22s)
- Frontend Unit Tests: 8/8 PASSED (5.52s)
- E2E Tests: 6/6 PASSED (13.9s)
**Dependencies**: Story 2.4 Done ✅, Story 4.1.5 Done ✅  
**Database Migration**: Completed (20251004000000_create_documents_table.sql)

