# Story 1.2: Admin Login System

**Status:** Done

## Story

**As a** Professore (Admin),
**I want** un sistema di login sicuro con credenziali,
**so that** le funzioni amministrative siano protette.

## Acceptance Criteria

1. Il backend espone un endpoint di login admin.
2. Le credenziali sono gestite in modo sicuro.
3. Un login con successo restituisce un token di sessione.
4. Il frontend ha una pagina di login.
5. Dopo il login, l'admin viene reindirizzato al pannello di controllo.
6. Il campo username/email non può essere inviato se vuoto.
7. Il campo password non può essere inviato se vuoto.
8. Un messaggio di errore specifico viene mostrato sotto il campo corrispondente se la validazione client-side fallisce.

## Dipendenze

- Non esplicitate nel PRD per questa story.

## Dev Notes

L'autenticazione è delegata a Supabase Auth. Il frontend utilizza `supabase-js` per il login e la gestione della sessione con persistenza e auto-refresh. Il backend valida i JWT su endpoint protetti tramite una dipendenza FastAPI basata su `PyJWT`, verificando firma, `exp` e `aud` contro il JWKS pubblico di Supabase.

### Specifiche API (Backend – Dependency FastAPI con PyJWT/JWKS)

```python
from typing import Annotated, Optional
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
import jwt  # PyJWT
from jwt import PyJWKClient, InvalidTokenError

app = FastAPI()

# Configurazione JWKS/JWT
SUPABASE_PROJECT_ID = "your-project-id"
JWKS_URL = f"https://{SUPABASE_PROJECT_ID}.supabase.co/auth/v1/.well-known/jwks.json"
EXPECTED_ISS = f"https://{SUPABASE_PROJECT_ID}.supabase.co/auth/v1"
EXPECTED_AUD = "authenticated"  # impostare secondo i claims del progetto

security = HTTPBearer(auto_error=False)
jwk_client = PyJWKClient(JWKS_URL)

def verify_jwt_token(
    credentials: Annotated[Optional[HTTPAuthorizationCredentials], Depends(security)]
):
    if credentials is None or credentials.scheme.lower() != "bearer":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing Bearer token")
    token = credentials.credentials
    try:
        signing_key = jwk_client.get_signing_key_from_jwt(token).key
        payload = jwt.decode(
            token,
            signing_key,
            algorithms=["RS256", "ES256"],  # coerente con la config del progetto
            audience=EXPECTED_AUD,
            issuer=EXPECTED_ISS,
            options={"require": ["exp", "iat"]},
        )
        return payload
    except InvalidTokenError as e:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token") from e

TokenPayload = dict

@app.get("/api/admin/me")
def admin_me(payload: Annotated[TokenPayload, Depends(verify_jwt_token)]):
    return {"ok": True, "sub": payload.get("sub")}
```

Fonti: JWT/JWKS Supabase (`/.well-known/jwks.json`), FastAPI Security (`HTTPBearer`), PyJWT (`PyJWKClient`).

### Specifiche Frontend (supabase-js)

```ts
import { createClient } from '@supabase/supabase-js'

const options = {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
}

export const supabase = createClient('https://xyzcompany.supabase.co', 'publishable-or-anon-key', options)
```

```ts
// Login
const { data, error } = await supabase.auth.signInWithPassword({
  email: 'example@email.com',
  password: 'example-password',
})
```

### Posizioni File
- Backend: `apps/api/api/main.py` (router/app)
- Frontend: `apps/web/src/` (pagina login, servizi API, routing)

### Vincoli Tecnici
- Stack esistente: React+Vite (TS) e FastAPI.
- Backend: aggiungere `PyJWT` per la validazione JWT via JWKS.
- Gestione segreti: variabili d'ambiente.

## Testing

### Approccio
- Unit, Integration, E2E (vedi `docs/architecture/sezione-11-strategia-di-testing.md`).

### Scenari chiave
1. Login con credenziali valide → 200 e sessione attiva; redirect a `/admin/dashboard`.
2. Credenziali non valide → 401 e messaggio di errore lato UI.
3. Campi vuoti (`email/username`, `password`) → blocco submit e messaggi di errore.
4. Chiamata a `/api/admin/me` con Bearer token valido → 200 e payload utente.
5. Chiamata a `/api/admin/me` senza/with token invalido → 401.

## Mitigazione dei Rischi di Sicurezza

- **SEC‑001 (gestione token insicura)**: JWT a vita breve con auto‑refresh lato client (`autoRefreshToken: true`), verifica lato server via JWKS (issuer/audience/exp), configurazione “JWT expiry limit” in Supabase.
- **SEC‑002 (brute‑force)**: affidamento ai rate‑limits Auth nativi di Supabase (verify/token/otp/recover/signup) e possibilità di CAPTCHA sugli endpoint di autenticazione.
- **SEC‑003 (storage token client‑side)**: persistenza sessione gestita da `supabase-js` (`persistSession: true`); nessun salvataggio custom insicuro.

## Tasks / Subtasks

- [ ] Backend: Aggiungere `PyJWT` alle dipendenze del progetto.
- [ ] Backend: Implementare la dependency `verify_jwt_token` come da esempio.
- [ ] Backend: Esporre rotta protetta `/api/admin/me` che usa la dependency.
- [ ] Frontend: Configurare il client Supabase con persistenza/auto‑refresh.
- [ ] Frontend: Implementare chiamata `signInWithPassword` nel form di login.
- [ ] Frontend: Inviare Bearer token nell'header `Authorization` verso endpoint protetti.

## QA Results

*(Da compilare da QA al review)*
