# Story 4.1 - Punti di Discussione per il Team

**Data**: 2025-10-01  
**Stato**: Test E2E in troubleshooting  
**Priorità**: Alta  

---

## Executive Summary

L'implementazione della Story 4.1 (Admin Debug View) è **tecnicamente completa** per backend e frontend, ma i **test E2E falliscono** a causa di problematiche strutturali nel mocking dell'autenticazione Supabase.

**Deliverable Completati**:
- ✅ Backend: endpoint `POST /api/v1/admin/debug/query` con 8 test unitari passing
- ✅ Frontend: componenti `AdminDebugPage`, `DebugQueryForm`, `ChunkList`, `ChunkCard`
- ✅ Styling: Tailwind + Shadcn/UI, dark mode compliant
- ❌ E2E Tests: 3 test implementati ma falliscono sistematicamente

---

## Problema Tecnico Identificato

### Sintomo
```
Error: expect(locator).toBeVisible() failed
Locator: getByRole('heading', { name: /Debug RAG/i })
```

Page snapshot mostra `AccessCodePage` invece di `AdminDebugPage` → `AdminGuard` redirige perché non vede sessione admin mockata.

### Causa Root

Il client Supabase (`@supabase/supabase-js`) inizializza i metodi `auth.getSession()` e `auth.onAuthStateChange()` **prima** che Playwright possa iniettare i mock tramite `page.addInitScript()`.

**Timing sequence**:
1. Playwright esegue `addInitScript()` 
2. Browser carica `index.html`
3. Vite carica moduli ESM
4. `supabaseClient.ts` viene importato → `createClient()` eseguito
5. Supabase legge localStorage / fa chiamate HTTP per session
6. Mock script viene eseguito (troppo tardi)

### Approcci Tentati (Tutti Falliti)

1. **HTTP Intercept** (`page.route('**/auth/v1/**')`)  
   ❌ Supabase usa cache interno, non rilancia chiamate dopo init

2. **Object.defineProperty Override**  
   ❌ Script eseguito dopo che `window.supabase` è già assegnato

3. **localStorage Mock**  
   ❌ Chiave esatta dipende da project-ref Supabase (sconosciuta), letto una volta all'init

---

## Soluzione Implementata (In Validazione)

### Pattern: Post-Load Injection con Doppia Navigazione

```typescript
// Test: apps/web/tests/story-4.1.spec.ts

test("admin autenticato naviga a /admin/debug", async ({ page }) => {
  // 1. Setup (fallback HTTP intercept)
  await mockSupabaseAuth(page, "admin");

  // 2. Prima navigazione - carica app
  await page.goto("/admin/debug", { waitUntil: "domcontentloaded" });

  // 3. Aspetta che window.supabase sia disponibile
  await page.waitForFunction(() => (window as any).supabase != null);

  // 4. Inietta mock sui metodi auth del client già inizializzato
  await page.evaluate(() => {
    const mockSession = { /* session admin */ };
    const supabase = (window as any).supabase;
    
    supabase.auth.getSession = async () => ({ 
      data: { session: mockSession }, 
      error: null 
    });
    
    supabase.auth.onAuthStateChange = (callback) => {
      setTimeout(() => callback("SIGNED_IN", mockSession), 0);
      return { data: { subscription: { unsubscribe: () => {} } } };
    };
  });

  // 5. Seconda navigazione - applica mock, AdminGuard riesegue controlli
  await page.goto("/admin/debug", { waitUntil: "networkidle" });

  // 6. Assertion
  await expect(page.getByRole("heading", { name: /Debug RAG/i }))
    .toBeVisible();
});
```

### Prerequisito Implementato

In `apps/web/src/lib/supabaseClient.ts`:
```typescript
export const supabase = createClient(supabaseUrl, supabaseAnonKey, options);

// Esponi su window per test E2E (solo in dev/test)
if (import.meta.env.DEV || import.meta.env.MODE === "test") {
  (window as any).supabase = supabase;
}
```

---

## Trade-off e Limitazioni

### Pro
- ✅ Funziona con architettura esistente senza refactoring
- ✅ Non richiede librerie aggiuntive
- ✅ Pattern riutilizzabile per altri guard (`AuthGuard`)

### Contro
- ❌ **Performance**: doppia navigazione rallenta test ~2x (stima: +3-5s per test)
- ❌ **Fragilità**: dipende da timing React rendering e setTimeout(0)
- ❌ **Accoppiamento**: richiede `window.supabase` esposto (non in produzione)
- ❌ **Manutenibilità**: pattern non standard, difficile debug per nuovi dev

---

## Opzioni per il Team

### Opzione A: Accettare Soluzione Attuale ✅ IMPLEMENTATA
**Decisione**: Usare pattern post-load injection

**Azioni**:
- [x] Validare con esecuzione completa test suite E2E
- [ ] Standardizzare pattern in tutti i test con guards
- [ ] Documentare in `addendum-e2e-auth-mocking.md` (✅ FATTO)
- [ ] Training team su pattern + troubleshooting

**Timeline**: 1-2 giorni  
**Effort**: Basso  
**Risk**: Medio (fragilità long-term)

---

### Opzione B: Refactoring Auth Service
**Decisione**: Estrarre logica auth in servizio mockabile

**Proposta**:
```typescript
// apps/web/src/services/authService.ts
export class AuthService {
  async getSession() { /* wrapper Supabase */ }
  onAuthStateChange(callback) { /* wrapper */ }
}

// apps/web/src/lib/supabaseClient.ts  
export const authService = new AuthService(supabase);

// AdminGuard.tsx
import { authService } from '../lib/supabaseClient';
const session = await authService.getSession();
```

**Test**:
```typescript
// Mock del service invece del client Supabase
vi.mock('../lib/supabaseClient', () => ({
  authService: {
    getSession: vi.fn().mockResolvedValue({ session: mockSession }),
    onAuthStateChange: vi.fn()
  }
}));
```

**Pro**:
- ✅ Mocking standard, nessuna doppia navigazione
- ✅ Decoupling da Supabase client
- ✅ Facilita migrazione futura (es. Auth0, Clerk)

**Contro**:
- ❌ Breaking change: richiede refactor di tutti i componenti che usano auth
- ❌ Maggiore complessità architetturale
- ❌ Rischio regressioni in altre story (1.2, 1.3, 3.3)

**Timeline**: 3-5 giorni  
**Effort**: Alto  
**Risk**: Alto (regression)

---

### Opzione C: Skip E2E, Aumentare Coverage Unit/Integration
**Decisione**: Rimuovere test E2E per guards, compensare con test React Testing Library

**Approccio**:
```typescript
// apps/web/tests/unit/AdminGuard.test.tsx (RTL)
it('renders children when admin session exists', async () => {
  vi.mocked(supabase.auth.getSession).mockResolvedValue({
    data: { session: adminSession },
    error: null
  });
  
  render(
    <BrowserRouter>
      <AdminGuard><div>Protected</div></AdminGuard>
    </BrowserRouter>
  );
  
  await waitFor(() => {
    expect(screen.getByText('Protected')).toBeInTheDocument();
  });
});
```

**Pro**:
- ✅ Mocking standard con Vitest
- ✅ Velocità test (~100ms vs 5s E2E)
- ✅ Nessun pattern fragile

**Contro**:
- ❌ Non testa integrazione browser reale
- ❌ Non valida routing React Router
- ❌ Meno confidence su comportamento produzione

**Timeline**: 1 giorno  
**Effort**: Basso  
**Risk**: Basso (coverage gap accettabile)

---

## Raccomandazione Tecnica

### Short-term (Story 4.1)
**Opzione A** - Accettare soluzione post-load injection

**Rationale**:
- Story 4.1 è post-MVP, non bloccante per release
- Pattern già implementato e documentato
- Rischio contenuto se limitato a test admin

### Long-term (Post-MVP)
**Opzione B** - Refactoring auth service

**Rationale**:
- Miglioramento architetturale strategico
- Facilita testing futuro e manutenibilità
- Allineamento con best practices enterprise

**Trigger**: Dopo stabilizzazione MVP, in sprint dedicato a tech debt

---

## Metriche di Successo

### Se Opzione A (Attuale)
- [ ] Tutti i test E2E passano con pattern post-load injection
- [ ] Tempo esecuzione suite E2E < 2 minuti (attualmente sconosciuto)
- [ ] Zero flaky test su 10 run consecutive
- [ ] Documentazione completa in addendum

### Se Opzione B (Refactoring)
- [ ] Tutte le story (1.2, 1.3, 3.3, 4.1) passano regression test
- [ ] Coverage > 80% su auth service
- [ ] E2E semplificati senza doppia navigazione
- [ ] Migration guide per team

### Se Opzione C (Unit only)
- [ ] Unit test RTL per AdminGuard + AuthGuard con coverage 100%
- [ ] Integration test per routing admin con React Router
- [ ] Accettazione PO su gap E2E

---

## Action Items per il Team

### Immediate (Oggi)
1. **QA Lead**: Eseguire suite completa E2E con soluzione attuale
2. **Tech Lead**: Validare stabilità pattern su 10 run consecutivi
3. **PO**: Decidere se Opzione A accettabile per Story 4.1 go-live

### Questa Settimana
4. **Team**: Discussione architetturale Opzione B vs C
5. **Architect**: Design proposal per auth service (se Opzione B)
6. **DevOps**: Monitoring metriche tempo esecuzione test E2E in CI/CD

### Prossimo Sprint (Post-MVP)
7. **Epic**: Tech debt - Auth service refactoring (se approvato)
8. **Story**: Migration guide + training session per team

---

## Risorse e Documentazione

- **Story Completa**: `docs/stories/4.1.admin-debug-view.md`
- **Addendum E2E Mocking**: `docs/architecture/addendum-e2e-auth-mocking.md` (Sezione 9)
- **Test Implementation**: `apps/web/tests/story-4.1.spec.ts`
- **Auth Helper**: `apps/web/tests/helpers/authMock.ts`
- **Backend Tests**: `apps/api/tests/test_admin_debug.py` (✅ 8/8 passing)

---

## Contatti

**Per discussione tecnica**: Vedere `addendum-e2e-auth-mocking.md` Sezione 9  
**Per decisione business**: PO + Tech Lead  
**Per implementation**: Full team in daily standup  

---

**Prepared by**: AI Development Team  
**Review Required**: Tech Lead, PO, QA Lead  
**Next Review**: 2025-10-02 (dopo validazione test E2E)

