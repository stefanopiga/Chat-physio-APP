# NFR Assessment — Story 9.2: Session History Retrieval & UI Integration

Date: 2025-11-12
Reviewer: Quinn (Test Architect & Quality Advisor)

Story: docs/stories/9.2-session-history-retrieval-ui.md

## Scope & Assumptions
- Scope: Recupero storico conversazioni via endpoint `GET /api/v1/chat/sessions/{sessionId}/history/full` e integrazione UI (hook `useSessionHistory`, API client `getSessionHistory`, ChatPage). Include feature flag per memoria persistente e pagination lazy-load per storici lunghi.
- Assumptions: Persistenza messaggi implementata in Story 9.1 (service `ConversationPersistenceService.load_session_history()`); autenticazione JWT attiva lato backend e già configurata a livello app; Vite env flag `VITE_ENABLE_PERSISTENT_MEMORY` governa comportamento client; nessun PII sensibile nei contenuti conversazionali oltre testo utente e risposte LLM; policy di retention disciplinata a livello DB.

## Summary Decision
- Security: PASS — JWT obbligatorio per endpoint; rate limiting 60/min per session; gestione 401 con redirect; nessun dato sensibile in querystring; header Authorization non loggato in frontend.
- Performance: PASS — Spinner iniziale target < 500ms; pagination per >100 messaggi; virtual scrolling >50 messaggi; retry backoff lato client per resilienza senza sovraccarico.
- Reliability: PASS — Degradazione graduale quando feature flag disattivo o in caso errori; retry 3 tentativi con backoff; 404 gestito come storico vuoto; 500 con toast e UI operativa.
- Availability: PASS — Rate limit per-session (60 req/min) limita blast radius; endpoint read-only su storage; nessun lock lungo.
- Scalability: PASS — Paginazione con `limit/offset` e `has_more`; virtual list per rendering efficiente; server-side access pattern lineare per session.
- Observability: PASS — Indicatori UI (spinner/loading, toast), console warn lato client, test E2E verificano stato; lato server log standard FastAPI/uvicorn (assunto) con SlowAPI headers.
- Maintainability: PASS — Tipi TS per `ConversationMessage` e `SessionHistoryResponse`; hook isolato; test unit/Vitest ed E2E Playwright presenti.
- Privacy/Compliance: PASS — Autenticazione JWT, nessun log di token; dati conversazione trattati come dati utente standard; nessun trasferimento a terze parti fuori dal cluster previsto.
- Cost: PASS — Operazioni read; costi marginali (DB read + traffico rete). Nessun uso LLM.

Gate: PASS (vedi blocco YAML).

## Evidence & Checks
- Security
  - Endpoint richiede JWT e applica rate limiting 60 req/min con 429 e `Retry-After` (docs/stories/9.2-session-history-retrieval-ui.md: AC1; Rate Limit Configuration).
  - Frontend reindirizza su 401; 404 trattato come sessione nuova senza errore (AC7, AC1–AC4 implementations e snippet client API).

- Performance
  - Target UX: spinner visibile durante fetch iniziale con percezione < 500ms (AC8). Paginazione per storici lunghi e virtual scrolling >50 messaggi riducono costi di rendering.
  - API supporta `limit` (default 100, max 500) e `offset` per scorrimento incrementale (AC1, AC8).

- Reliability & Availability
  - Retry client 3 tentativi con exponential backoff (1s→2s→4s) per network/5xx; 404 nuovo → array vuoto; 500 → toast + UI continua operativa (AC7).
  - Feature flag `VITE_ENABLE_PERSISTENT_MEMORY` consente degradazione a stato vuoto senza bloccare UI (AC6).

- Observability & Operability
  - UI indicator “Caricamento storico…” e indicator load-more durante pagination; console warning in caso di errore; test E2E con asserzioni su indicatori e messaggi.
  - SlowAPI espone `Retry-After` su 429 come riferimento operativo.

- Maintainability
  - API client tipizzato, hook con stato coeso (`messages`, `isLoadingHistory`, `hasMoreMessages`, `error`), dedup IDs in pagination; test unit per API client e hook; E2E copre flussi principali.

- Privacy/Compliance
  - Nessun log client di contenuti oltre a warn generici; header Authorization usato solo in request; nessuna telemetria di contenuti inviata a terzi.

## Recommendations (Must/Should)
- Must
  - Aggiungere header caching hints lato backend: `Cache-Control: private, max-age=0, no-store` per evitare caching proxy indesiderato di storici per-utente.
  - Validare server-side bounds di `limit` (≤ 500) e `offset` (≥ 0) con risposte 400 coerenti; documentare nel modello OpenAPI.
  - Mascherare eventuali `source_chunk_ids` sensibili nei log server (se presenti) e assicurare che non contengano PII.

- Should
  - Esportare metriche (se Prometheus attivo): count richieste per session, 401/404/429/5xx rate, p95/p99 latency endpoint history, payload size medio.
  - UI: telemetry opzionale non PII su “time-to-first-history-render” e “messages_rendered_count” per monitorare regressioni UX.
  - Documentare comportamento su `has_more=true` per UX consistenti (auto-load vs. manual “Carica altri”).

## Validation Scenarios (Given-When-Then)
- Given sessione esistente con 2 messaggi When apro ChatPage Then UI mostra spinner, poi i 2 messaggi e `has_more=false` entro TTFB < 500ms.
- Given storico > 100 messaggi When pagino con `offset=100` Then ricevo batch successivo e UI fa prepend senza duplicati mantenendo scroll position.
- Given rete instabile When la fetch fallisce 2 volte Then al 3° tentativo con backoff l’API risponde 200 e l’UI completa il caricamento.
- Given server risponde 404 nuova sessione When chiamo endpoint Then ritorna `{ messages: [], total_count: 0, has_more: false }` e UI resta operativa.
- Given risposta 401 When chiamo endpoint senza JWT valido Then client effettua redirect a login e non espone dettagli di errore.
- Given rate limit superato When ricevo 429 con `Retry-After` Then il client backoffa e riprova senza superare 60/min per sessione.
- Given risposta 500 When carico history Then compare toast “Impossibile caricare storico, riprova” e input chat resta attivo.

## Metrics & Thresholds
- UX: time-to-first-history-render (cold) ≤ 500ms percepito; indicatori visivi sempre presenti durante fetch.
- API: p95 `GET /history/full` ≤ 250ms per batch 100; 5xx rate < 1%; 429 rate < 2% sostenuto.
- Pagination: nessun duplicato ID; coerenza `total_count`; `has_more` corretto in tutti i batch.
- Rendering: virtual list mantiene main-thread blocking < 16ms median per >50 messaggi.

## Gate Block (merge/copy into gate file)

```yaml
nfr_validation:
  _assessed: [security, performance, reliability, availability, scalability, observability, maintainability, privacy, cost]
  security:
    status: PASS
    notes: 'JWT richiesto; rate limit per sessione; 401 redirect; no token logging.'
  performance:
    status: PASS
    notes: 'Spinner <500ms percepito; pagination 100; virtual scrolling >50.'
  reliability:
    status: PASS
    notes: 'Retry 3x backoff; 404→vuoto; 500→toast; feature flag per degrado.'
  availability:
    status: PASS
    notes: 'Endpoint read; rate limit isola per sessione; nessun lock lungo.'
  scalability:
    status: PASS
    notes: 'Limit/offset + has_more; rendering virtualizzato.'
  observability:
    status: PASS
    notes: 'Indicatori UI; console warn; SlowAPI headers; test E2E coprono.'
  maintainability:
    status: PASS
    notes: 'Tipi TS; hook isolato; test unit + E2E.'
  privacy:
    status: PASS
    notes: 'Nessun log di token/dati sensibili; dati utente trattati localmente.'
  cost:
    status: PASS
    notes: 'Sola lettura DB; costi marginali.'
```

Artifacts: docs/qa/assessments/9.2-nfr-20251112.md

Next: aggiornare/creare gate `docs/qa/gates/9.2-session-history-retrieval-ui-integration.yml` se necessario, inserendo il blocco `nfr_validation` sopra.

