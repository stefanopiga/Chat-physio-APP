# Story 5.4 — Test Design (Test Suite Critical Fixes & Environment Isolation)

Data: 2025-10-09
ID: QA-TD-5.4
Riferimento: docs/stories/5.4-test-suite-critical-fixes.md

## Obiettivi di Verifica
- Validare la disabilitazione del rate limiting in ambiente test e l’isolamento degli stati.
- Verificare allineamento schema response API (documents, knowledge_base).
- Garantire integrità referenziale nelle fixture DB (`student_tokens`).
- Completare migrazione import e prevenire residui legacy.
- Allineare configurazione JWT (audience/issuer/expiry/leeway) tra generazione e validazione.
- Confermare assenza di timeout E2E post-fix e tracciare eventuali colli di bottiglia.

## Ambito
- Backend API (`apps/api`) — suite pytest
- Esclusioni: Frontend e2e non coperti in questa story

## Requisiti/Env
- Python 3.11, Poetry
- Supabase di test accessibile
- Env test forzato: `TESTING=true`, `RATE_LIMITING_ENABLED=false`

## Strategia di Test
- Sequenza per fasi (P0→P3), con validazione incrementale
- Test per categoria con assert mirati e fixture di isolamento
- Verifica di regressione post-fix per categorie precedentemente fallenti

---

## Piano di Test per Fase

### Fase 1 — Rate Limiting Bypass (P0)

#### TD1.1 — Env Flag e Registrazione Condizionale
- Scopo: verificare `settings.should_enable_rate_limiting == False` in test
- Passi:
  1. Impostare env `TESTING=true`, `RATE_LIMITING_ENABLED=false`
  2. Avviare app e ispezionare log per “Rate limiting DISABLED”
- Evidenze: log applicativi; `app.state.limiter` non presente
- Esito: PASS se limiter non registrato

#### TD1.2 — Nessun 429 in Suite Mirata
- Scopo: assenza di 429 per test admin/analytics
- Comando:
  ```bash
  cd apps/api
  poetry run pytest tests/routers/test_admin.py tests/test_admin_debug.py tests/test_analytics.py -v
  ```
- Oracolo: nessun assert 429

#### TD1.3 — Pulizia store RL
- Scopo: fixture `clean_rate_limit_store` eseguita
- Passi: introdurre contatore dummy in fixture e verificare reset
- Esito: PASS se lo store è vuoto a inizio/fine test

### Fase 2 — API Response Schema (P0)

#### TD2.1 — Documents: campi base presenti
- Scopo: response include `document_id`, `chunks`, `total_chunks`
- Comando:
  ```bash
  poetry run pytest tests/routers/test_documents.py::test_get_document_chunks_success -v
  ```
- Oracolo: nessun KeyError; valori coerenti

#### TD2.2 — Documents: paginazione
- Scopo: `limit/offset` rispettati e `total_chunks` corretto
- Comando:
  ```bash
  poetry run pytest tests/routers/test_documents.py::test_get_document_chunks_pagination -v
  ```
- Oracolo: dimensione pagina == limit; total coerente

#### TD2.3 — Documents: ordinamento per `chunk_size`
- Scopo: query con `ORDER BY c.chunk_size`
- Comando:
  ```bash
  poetry run pytest tests/routers/test_documents.py::test_get_document_chunks_sort_by_size -v
  ```
- Oracolo: assert su query o risultato ordinato

#### TD2.4 — Knowledge Base: `similarity_score`
- Scopo: ogni result ha `similarity_score`
- Comando:
  ```bash
  poetry run pytest tests/routers/test_knowledge_base.py::test_search_endpoint_authenticated -v
  ```
- Oracolo: KeyError assente; valori float 0..1 plausibili

### Fase 3 — Fixture DB e FK (P0)

#### TD3.1 — Creazione parent `auth.users`
- Scopo: fixture crea/upserta utente admin
- Passi: eseguire test student_tokens e verificare nessun `postgrest.exceptions.APIError`
- Comando:
  ```bash
  poetry run pytest tests/routers/test_auth.py -v -k "student_token"
  poetry run pytest tests/test_student_tokens.py -v
  ```
- Oracolo: 0 errori FK

#### TD3.2 — Cleanup idempotente
- Scopo: records rimossi al teardown
- Passi: eseguire test due volte e verificare assenza conflitti uniqueness
- Oracolo: nessun conflitto on_conflict

### Fase 4 — Migrazione Import (P1)

#### TD4.1 — Audit automatico import legacy
- Scopo: `legacy_imports.txt` vuoto
- Comando:
  ```bash
  cd apps/api
  poetry run python scripts/audit_legacy_imports.py > legacy_imports.txt
  ```
- Oracolo: conteggio 0

#### TD4.2 — Import specifici corretti
- Scopo: verify_jwt_token, perform_semantic_search, CreateStudentTokenRequest
- Comandi:
  ```bash
  poetry run pytest tests/test_indexing_admin.py -v
  poetry run pytest tests/test_performance_semantic_search.py -v
  poetry run pytest tests/test_student_tokens.py::test_create_student_token_request_validation -v
  ```
- Oracolo: nessun ImportError/AttributeError

### Fase 5 — JWT Configuration (P2)

#### TD5.1 — Audience e Issuer coerenti
- Scopo: `aud=authenticated`, `iss=settings.jwt_issuer`
- Comando:
  ```bash
  poetry run pytest tests/services/test_auth_service.py::test_generate_temp_jwt_structure -v
  ```
- Oracolo: nessuna InvalidAudienceError

#### TD5.2 — Expiry type corretto
- Scopo: `temp_jwt_expires_minutes` trattato come int
- Comando:
  ```bash
  poetry run pytest tests/services/test_auth_service.py::test_generate_temp_jwt_different_subjects_unique -v
  ```
- Oracolo: nessun TypeError timedelta

### Fase 6 — E2E Timeout (P3)

#### TD6.1 — Timeout esteso e checkpoint
- Scopo: identificare stage lento
- Comando:
  ```bash
  poetry run pytest tests/test_pipeline_e2e.py -v -s
  ```
- Oracolo: stampa checkpoint; nessun TimeoutError con @timeout(120)

---

## Criteri di Accettazione (Riallineati)
- AC1: 0 risposte 429 in ambiente test; limiter disabilitato
- AC2: Schema API soddisfatto per documents e KB
- AC3: Nessuna violazione FK; fixture idempotenti
- AC4: Nessun import legacy; test mirati passano
- AC5: JWT claims e decode coerenti; nessun errore
- NFR: Durata suite ≤400s; pass rate >90%; errors 0

## Test di Regressione
- Eseguire suite completa:
  ```bash
  cd apps/api
  poetry run pytest tests/ -v --tb=short --cov=api --cov-report=term-missing
  ```
- Verificare: nessun fail riaperto; coverage ≥93%

## Evidenze Richieste
- Output pytest per categoria e suite completa
- File `legacy_imports.txt`
- Log app: messaggio disabilitazione rate limiting
- Eventuali query SQL o tracce per ordinamento/paginazione

## Rischi del Test
- Dipendenza da Supabase test: instabilità ambientale
- Falsi positivi se env vars non applicate prima degli import
- Interazioni tra fixture locali e globali (dupliche)

## Conclusione
Il test design copre le fasi P0–P3 della Story 5.4 con verifiche incrementali e controlli di regressione, finalizzati allo sblocco della CI e all’allineamento del contratto API.