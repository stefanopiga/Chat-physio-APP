# Test Design — Story 3.3: Frontend Chat Integration

## Riferimenti
- Fonte primaria: `docs/stories/3.3.frontend-chat-integration.md`

## Obiettivi di Test
- Verificare che la UI invochi l'endpoint di query secondo l'AC. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria"]
- Verificare la visualizzazione dell'indicatore di caricamento durante le chiamate. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria"]
- Verificare la visualizzazione della risposta nella UI. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria"]
- Verificare il mantenimento della cronologia della sessione lato client. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria"]
- Assicurare il flusso UI: `queryChunks(question)` → `sendMessage(sessionId, question, chunks)` con `sessionId` persistito. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Flusso UI", "Componenti Frontend"]
- Gestire correttamente 401/429/500 secondo specifica di errore. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Error Handling"]

## Endpoints/Componenti rilevanti
- Endpoints backend disponibili: `POST /api/v1/chat/query`, `POST /api/v1/chat/sessions/{sessionId}/messages`; auth JWT; rate limiting `60/min`. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Contexto Tecnico"]
- Componenti: `ChatPage`, `ChatInput`, `ChatMessagesList`, `apiClient` (`queryChunks`, `sendMessage`). [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Componenti Frontend"]

## Strategia di Testing
- Test di integrazione UI con mocking dell'`apiClient`: verifica chiamate, loader e rendering della risposta. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Testing"]
- E2E (se presente): invio domanda e visualizzazione risposta. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Testing"]

## Casi di Test

### AC1 — La UI chiama l'endpoint di query
- TC-001 — Invio domanda: la UI invoca l'endpoint definito negli AC (`/api/v1/chat/query`) tramite `apiClient.queryChunks`. Assert: endpoint chiamato con payload domanda. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria", "Flusso UI"]
- TC-002 — Propagazione errori di rete: mock errore rete → UI gestisce stato errore senza crash. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Testing"]

### AC2 — Indicatore di caricamento
- TC-010 — Loader visibile durante la chiamata a `queryChunks`/`sendMessage` e nascosto al completamento. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Acceptance Criteria", "Componenti Frontend"]

### AC3 — Visualizzazione risposta
- TC-020 — Risposta di `sendMessage`: render del testo risposta nel componente messaggi. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Flusso UI"]
- TC-021 — Citazioni: placeholder presente per citazioni (implementazione completa in 3.4). [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Componenti Frontend"]

### AC4 — Cronologia sessione
- TC-030 — Persistenza `sessionId` su client: riuso tra invii nella stessa sessione. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Flusso UI"]
- TC-031 — Aggiornamento cronologia locale dopo ogni messaggio. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Flusso UI"]

### Error Handling (UI)
- TC-040 — 401: mock risposta 401 da API → redirect a login. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Error Handling"]
- TC-041 — 429: mock risposta 429 → mostra messaggio di rate limit. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Error Handling", "Contexto Tecnico"]
- TC-042 — 500: mock risposta 500 → toast errore generico. [Fonte: `docs/stories/3.3.frontend-chat-integration.md` "Error Handling"]

### E2E (Prerequisiti e Best Practices)
- Impostare credenziali fittizie prima del `goto` quando la rotta è protetta da `AuthGuard`:
```ts
await page.addInitScript(() => {
  localStorage.setItem("chat.sessionId", "e2e-session-id");
  sessionStorage.setItem("temp_jwt", "e2e-temp-token");
});
await page.goto("/chat");
```
- Attendere sblocco di `AuthGuard` prima di interagire:
```ts
await expect(page.getByText("Verifica autenticazione...")).not.toBeVisible({ timeout: 10000 });
```
- Usare selettori resilienti e attese esplicite per elementi lenti:
```ts
const input = page.getByPlaceholder("Inserisci la tua domanda...");
await expect(input).toBeVisible({ timeout: 10000 });
```
- Attendere l’abilitazione del submit per form reattivi:
```ts
const submit = page.getByRole("button", { name: "Invia" });
await expect(submit).toBeEnabled();
```
- Verificare post-condizione loader off:
```ts
await expect(page.getByText("Caricamento...")).not.toBeVisible({ timeout: 10000 });
```
- Verificare redirect delle rotte protette attendendo l’URL target o un heading stabile della pagina di destinazione:
```ts
await page.goto("/admin/dashboard");
await page.waitForURL("/", { timeout: 10000 });
await expect(page.getByRole("heading", { name: /Accesso Studente/i })).toBeVisible();
```

## Metriche
- non disponibile nella fonte
